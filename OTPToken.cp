// Newton C++ Includes#include "NewtonScript.h"#include "UStringUtils.h"#include "time.h"// Project Related-headers#include "sha1.h"#include "hmac.h"#include "base32.h"#ifdef __cplusplus#define EXTERNC extern "C"#else#define EXTERNC#endif// generateCode() function from// github.com/google/google-authenticator-libpam#define	BITS_PER_BASE32_CHAR 5#define VERIFICATION_CODE_MODULUS (1000*1000)static int generateCode(const char *key, unsigned long tm) {  uint8_t challenge[8];  for (int i = 8; i--; tm >>= 8) {    challenge[i] = tm;  }  // Estimated number of bytes needed to represent the decoded secret. Because  // of white-space and separators, this is an upper bound of the real number,  // which we later get as a return-value from base32_decode()  int secretLen = (strlen(key) + 7)/8*BITS_PER_BASE32_CHAR;  // Sanity check, that our secret will fixed into a reasonably-sized static  // array.  if (secretLen <= 0 || secretLen > 100) {    return -1;  }  // Decode secret from Base32 to a binary representation, and check that we  // have at least one byte's worth of secret data.  uint8_t secret[100];  if ((secretLen = base32_decode((const uint8_t *)key, secret, secretLen))<1) {    return -1;  }  // Compute the HMAC_SHA1 of the secrete and the challenge.  uint8_t hash[SHA1_DIGEST_LENGTH];  hmac_sha1(secret, secretLen, challenge, 8, hash, SHA1_DIGEST_LENGTH);  // Pick the offset where to sample our hash value for the actual verification  // code.  int offset = hash[SHA1_DIGEST_LENGTH - 1] & 0xF;  // Compute the truncated hash in a byte-order independent loop.  unsigned int truncatedHash = 0;  for (int i = 0; i < 4; ++i) {    truncatedHash <<= 8;    truncatedHash  |= hash[offset + i];  }  // Truncate to a smaller number of digits.  truncatedHash &= 0x7FFFFFFF;  truncatedHash %= VERIFICATION_CODE_MODULUS;  return truncatedHash;}// GetGMTOffset - reach over to the NewtonScript-side and pull// back the GMT offset for the current timezone in seconds.int GetGMTOffset() {	Ref globals = NSCallGlobalFn(SYM(GetGlobals));	if (globals == NILREF) return 0;		Ref userConfig = GetFrameSlot(globals, SYM(userConfiguration));	if (userConfig == NILREF) return 0;		Ref location = GetFrameSlot(userConfig, SYM(location));	if (location == NILREF) return 0;		Ref gmt = GetFrameSlot(location, SYM(gmt));	if (gmt == NILREF) return 0;		return RefToInt(gmt);}// Get the time in terms of the unix epoch.  Return as binary becase// NewtonScript's integer type is only 30 bits.EXTERNC Ref GetUnixTime(RefArg rcvr) {  time_t now = time(NULL);  now -= 2082844800UL;  now -= GetGMTOffset();  RefVar bin = AllocateBinary(SYM(binary), sizeof(time_t));  WITH_LOCKED_BINARY(bin, binPtr)  memcpy(binPtr, &now, sizeof(time_t));  END_WITH_LOCKED_BINARY(bin)	  return bin;}// Given the Base32 secret, calculate the OTP 6-digit codeEXTERNC Ref GetTOTP(RefArg rcvr, RefArg base32String){	long length;				WITH_LOCKED_BINARY(base32String, strPtr)	length = Ustrlen((UniChar*)strPtr);	END_WITH_LOCKED_BINARY(base32String)			unsigned char* cStr = (unsigned char*)malloc(length+1);		// Convert the UniChar string to a standard cString	WITH_LOCKED_BINARY(base32String, strPtr)		for (int x=0; x<length; x++) {			cStr[x] = ((char*)strPtr)[1+(x*2)];		}	END_WITH_LOCKED_BINARY(base32String)	cStr[length] = 0x00; //Null terminator		// Get the time in terms of the unix epoch	time_t now = time(NULL);  // get the time    now -= 2082844800UL;	  // convert to unix epoch	now -= GetGMTOffset();	  // convert to GMT    	// Generate the hash	int hash = generateCode((const char*)cStr, now/30); 	// Free the string pointer	free(cStr);		// Return the hash	return MakeInt(hash);}